'' =================================================================================================''''   File....... jm_strings.spin''   Purpose.... Miscellaneous string methods''   Author..... Jon "JonnyMac" McPhalen (aka Jon Williams)''               -- see below for terms of use''   E-mail..... jon@jonmcphalen.com''   Started.... ''   Updated.... 12 NOV 2011'''' ================================================================================================={  All methods are atomic to allow inclusion in any program.  }pub ucstr(spntr)'' Converts z-string at pntr to upper case  repeat strsize(spntr)    byte[spntr] := ucase(byte[spntr])    spntr++  pub ucase(c) '' Convert c to uppercase'' -- does not modify non-alphas  if ((c => "a") and (c =< "z"))    c -= 32  return cpub lcstr(spntr)'' Converts z-string at pntr to lower case  repeat strsize(spntr)    byte[spntr] := lcase(byte[spntr])    spntr++ pub lcase(c)'' Convert c to lowercase'' -- does not modify non-alphas  if ((c => "A") and (c =< "Z"))    c += 32  return cpub strncmp(str1, str2, n) | match'' Compares n characters of str2 with str1'' -- str1 and str2 are pointers to strings'' -- 0 if str1 == str2, 1 if str1 > str2, -1 if str1 < str2  match := 0  if (n > 0)    repeat n      if (byte[str1] > byte[str2])        ++match        quit      elseif (byte[str1] < byte[str2])          --match        quit      else        ++str1        ++str2  return match                                                             pub instr(str1, str2) | len1, len2, pos, idx'' Returns position of str2 in str1'' -- if str2 not in str1 returns -1  len1 := strsize(str1)  len2 := strsize(str2)  pos  := -1                                             idx  := 0  if (len1 >= len2)                                        repeat (len1 - len2 + 1)                                 if (byte[str1] == 0)                                     quit      else        if (strncmp(str1++, str2, len2) == 0)                    pos := idx                                             quit                                                 else          ++idx  return pospub strncopy(str1, str2, n) | c'' Copies n characters from str2 to str1'' -- str1 and str2 are pointers to strings  repeat n    c := byte[str2++]    byte[str1++] := c    if (c == 0)      quitcon  ' numeric conversionspub asc2val(pntr) | c'' Returns value of numeric string'' -- binary (%) and hex ($) must be indicated  repeat    c := byte[pntr]    case c       " ":                                                      ' skip leading space(s)            pntr++      "-", "0".."9":                                            ' found decimal value        return asc2dec(pntr, 11)      "%":                                                      ' found binary value        return bin2dec(pntr, 32)      "$":                                                      ' found hex value        return hex2dec(pntr, 8)            other:                                                    ' abort on bad character        return 0pub asc2dec(spntr, n) | c, value, sign'' Returns signed value from decimal string'' -- pntr is pointer to decimal string'' -- n is maximum number of digits to process  if (n < 1)                                                    ' if bogus, bail out    return 0   repeat    c := byte[spntr]    case c       " ":                                                      ' skip leading space(s)        spntr++      "-", "0".."9":                                            ' found value        if (c == "-")                                           ' sign symbol?          sign := -1                                            '  yes, set sign          spntr++                                               '  advance pointer        else          sign := 1                                             ' value is positive        quit      other:                                                    ' abort on bad character        return 0          value := 0  n <#= 10                                                      ' limit chars in value    repeat while (n)    c := byte[spntr++]                                              case c      "0".."9":                                                 ' digit?        value := (value * 10) + (c - "0")                       '  update value        n--                                                     '  dec digits count      "_":        ' skip      other:        quit  return sign * value       pub bin2dec(spntr, n) | c, value'' Returns value from {indicated} binary string'' -- pntr is pointer to binary string'' -- n is maximum number of digits to process  if (n < 1)                                                    ' if bogus, bail out    return 0   repeat    c := byte[spntr]    case c       " ":                                                      ' skip leading space(s)         spntr++      "%":                                                      ' found indicator        spntr++                                                 '  move to value        quit            "0".."1":                                                 ' found value        quit      other:                                                    ' abort on bad character        return 0  value := 0  n <#= 32                                                      ' limit chars in value  repeat while (n)                                                                          c := byte[spntr++]                                          ' get next character    case c      "0".."1":                                                 ' binary digit?        value := (value << 1) | (c - "0")                       '  update value        --n                                                     '  dec digits count      "_":        ' skip      other:        quit      return valuepub hex2dec(pntr, n) | c, value'' Returns value from {indicated} hex string'' -- pntr is pointer to binary string'' -- n is maximum number of digits to process  if (n < 1)                                                    ' if bogus, bail out    return 0   repeat    c := ucase(byte[pntr])    case c       " ":                                                      ' skip leading space(s)        pntr++      "$":                                                      ' found indicator        pntr++                                                  '  move to value        quit        "0".."9", "A".."F":                                       ' found value        quit       other:                                                    ' abort on bad character        return 0  value := 0  n <#= 8                                                       ' limit field width  repeat while (n)    c := ucase(byte[pntr++])    case c      "0".."9":                                                 ' digit?        value := (value << 4) | (c - "0")                       '  update value        --n                                                     '  dec digits count      "A".."F":                                                 ' hex digit?        value := (value << 4) | (c - "A" + 10)         --n      "_":        ' skip      other:        quit   return value   dat{{  Terms of Use: MIT License  Permission is hereby granted, free of charge, to any person obtaining a copy of this  software and associated documentation files (the "Software"), to deal in the Software  without restriction, including without limitation the rights to use, copy, modify,  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to  permit persons to whom the Software is furnished to do so, subject to the following  conditions:  The above copyright notice and this permission notice shall be included in all copies  or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}